/***********************************************************
 Copyright (c) 2013- Han Wenfang (eehanwenfang@foxmail.com)
 Distributed under the ATing-- Software LICENSE

 The main source code of ATing code-gen program.

************************************************************/

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <locale>

#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

using namespace std;

string const version = "1.0";

string makefile_comment()
{
	return
		string("##") + "\n" + 
		"# Autogenerated by ATing-- C++ Development Framework" + "( " + version + " )" +
		"\n" + "# You can modify it to suit your application." + "\n" +
		"#";
}

string source_comment()
{
	return
		string("//") + "\n" + 
		"// Autogenerated by ATing-- C++ Development Framework" + "( " + version + " )" +
		"\n" + "// You can modify it to suit your application." + "\n" +
		"//";
}

// check wether file exists or not 
bool is_exist(std::string file_path)
{
	if(access(file_path.c_str(), F_OK) < 0)
		return false;
	else
		return true;
}

// include target 
string dep_command(vector<string> &objects)
{
	string commd;
	commd += "default: ";
	for(vector<string>::iterator it=objects.begin(); it != objects.end(); ++it)
	{
		commd += "$(ROBJDIR)/";
		commd += *it;
		commd += ".o ";

		commd += "$(DOBJDIR)/";
		commd += *it;
		commd += "d.o ";
	} 
	commd += "$(BINDIR)/$(target) ";
	commd += "$(BINDIR)/$(target)d";

	return commd;
}

// obj part in makefile
int obj_command_template(ofstream &file, string &object, map<string, string> &remember)
{
	if(remember.find(object) != remember.end())
	{
		file << "$(ROBJDIR)/" << object << ".o:" << remember[object] << endl;
		file << "\t" << "$(CPP) $(INCLUDE) $(RELEASEOPT_CPP) -c $< -o $@" << endl << endl;

		file << "$(DOBJDIR)/" << object << "d" << ".o:" << remember[object] << endl;
		file << "\t" << "$(CPP) $(INCLUDE) $(DEBUGOPT_CPP) -c $< -o $@" << endl << endl;
	}
	else
	{
		file << "$(ROBJDIR)/" << object << ".o: $(SRCDIR)/" << object << 
		".cpp $(INCDIR)/" << object << ".h" << endl;
		file << "\t" << "$(CPP) $(INCLUDE) $(RELEASEOPT_CPP) -c $< -o $@" << endl << endl;

		file << "$(DOBJDIR)/" << object << "d" << ".o: $(SRCDIR)/" << object << 
		".cpp $(INCDIR)/" << object << ".h" << endl;
		file << "\t" << "$(CPP) $(INCLUDE) $(DEBUGOPT_CPP) -c $< -o $@" << endl << endl;
	}

	return 0;
}

//get the first token of the line
string get_token(string &line)
{
	unsigned int i = 0;
	string temp;
	while(line[i] != ' ' && i < line.size())
	{
		temp.push_back(line[i]);
		++i;
	}
	return temp;
}

// get user configuration in the Makefile
void get_user_add(ifstream &makefile, vector<string> &userConfig)
{
	string line;
	string firstSym;
	while(std::getline(makefile,line))
	{
		firstSym = get_token(line);
		//cout << line << endl;
		//cout << firstSym << endl;
		if (firstSym == "APP_ADD_INCLUDE")
		{
			userConfig.push_back(string(line, 18));
		}
		else if(firstSym == "APP_ADD_LIBRARY")
		{
			userConfig.push_back(string(line, 18));

		}
		else if(firstSym == "target")
		{
			userConfig.push_back(string(line, 16));

		}
		else if(firstSym == "target_version")
		{
			userConfig.push_back(string(line, 16));
		}
		else if(firstSym == "dep_libs")
		{
			userConfig.push_back(string(line, 13));
		}
		else if(firstSym == "SYSLIBS")
		{
			userConfig.push_back(string(line, 10));
		}
		else
		{

		}
	}
}

int main(int argc, char *argv[])
{
	if(argc < 3)
	{
		cout << "Please input more module names:" << endl;
		cout << "\t" << "For example:" << endl;
		cout << "\t" << "\t" << "scaffold-gen APP1 server client" << endl;
	}
	else
	{
		string const src = "src";
		string const incl = "include";
		string const build_system = "BuildSystem";
		string const output = "output";
		string const obj = "obj";
		string const lib = "lib";
		string const bin = "bin";
		string const cur_dir = "./";
		string const f_makefile = "Makefile";
		string const components = "components";

		string const src_path = cur_dir + src;
		string const incl_path = cur_dir + incl;
		string const output_dir_path = cur_dir + output;
		string const obj_dir_path = output_dir_path + "/" + obj;
		string const release_obj_dir_path = obj + "/" + "release";
		string const debug_obj_dir_path = obj + "/" + "debug";
		string const lib_dir_path = output_dir_path + "/" + lib;
		string const bin_dir_path = output_dir_path + "/"  + bin;
		string const f_makefile_path = cur_dir + f_makefile;
		string const components_path = cur_dir + components;
		string const build_system_path = cur_dir + build_system;
		string const build_system_obj_path = build_system_path + "/" + "obj";

		mkdir(src_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);
		mkdir(incl_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);
		mkdir(output_dir_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);
		mkdir(obj_dir_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);
		mkdir(release_obj_dir_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);
		mkdir(debug_obj_dir_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);
		mkdir(lib_dir_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);
		mkdir(bin_dir_path.c_str(),S_IRWXU | S_IRWXG | S_IRWXO);

		vector< string > f_src;
		string temp_argc;
		string temp_argc_h;
		string temp_argc_cpp;
		string upper_temp_argc;
		ofstream src_file; 

		string APP_NAME = argv[1];

		for(int i = 2; i <= argc-1; ++i)
		{
			temp_argc = argv[i];
			temp_argc_h = incl_path + "/" + temp_argc + ".h";
			temp_argc_cpp = src_path + "/" + temp_argc + ".cpp";

			// .h
			if(is_exist(temp_argc_h.c_str()))
			{
				cout << temp_argc_h << " already exists" << endl;
				return 0;
			}
			src_file.open(temp_argc_h.c_str());
			src_file << source_comment() << endl;
			src_file << endl << endl;
			upper_temp_argc = temp_argc;
			transform(upper_temp_argc.begin(), upper_temp_argc.end(), upper_temp_argc.begin(), ::toupper);
			src_file << "#ifndef " << APP_NAME << "_" << upper_temp_argc << "_H" << endl;
			src_file << "#define " << APP_NAME << "_" << upper_temp_argc << "_H" << endl;
			src_file << endl;
			src_file << "namespace " << APP_NAME << " " << "{ " << endl;
			src_file << endl << endl;
			src_file << "class " << temp_argc << " " << endl;
			src_file << "{" << endl;
			src_file << endl << endl << endl << endl << endl;
			src_file << "};" << endl;
			src_file << endl;
			src_file << "} // namespace " << APP_NAME << endl;
			src_file << "#endif" << endl;
			src_file.close();
			
			// .cpp
			if(is_exist(temp_argc_cpp.c_str()))
			{
				cout << temp_argc_cpp << " already exists" << endl;
				return 0;
			}
			src_file.open(temp_argc_cpp.c_str());
			src_file << source_comment() << endl;
			src_file << endl << endl;
			src_file << "#include " << "\"" << temp_argc << ".h" << "\"" << endl << endl << endl;
			src_file << "namespace " << APP_NAME << " " << "{ " << endl;
			src_file << endl << endl;
			src_file << endl << endl << endl << endl << endl;
			src_file << "} // namespace " << APP_NAME << endl;
			src_file.close();

			// component
			src_file.open(components_path.c_str(),ofstream::app);
			src_file << argv[i] << endl;
			src_file.close();
		}

		// Makefile UI
		vector<string> userAdd;
		if (is_exist(f_makefile_path))
		{
			//cout << "Makefile already exist" << endl;
			ifstream mkfile(f_makefile_path.c_str());
			get_user_add(mkfile,userAdd);
			mkfile.close();
		}
		else
		{
			userAdd.push_back(" ");
			userAdd.push_back(" ");
			userAdd.push_back(" ");
			userAdd.push_back(" ");
			userAdd.push_back(" ");
			userAdd.push_back(" ");
		}

		ofstream mkfile;
		mkfile.open(f_makefile_path.c_str());
		mkfile << makefile_comment() << endl << endl;
		mkfile << "cwd = $(shell pwd)" << endl << endl;
		mkfile << "APP_ADD_INCLUDE += " << userAdd[0] << endl;
		mkfile << "APP_ADD_LIBRARY += " << userAdd[1] << endl;
		mkfile << endl;
		mkfile << "objects = ";

		ifstream components_file(components_path.c_str());
		string object;
		vector<string> objects_buffer;
		while(getline(components_file,object))
		{
			mkfile << object << " ";
			objects_buffer.push_back(object);
		}
		components_file.close();

		mkfile << endl;
		mkfile << "target         = " << userAdd[2] << endl;
		mkfile << "target_version = " << userAdd[3] << endl;
		mkfile << "dep_libs    = " << userAdd[4] << endl;
		mkfile << endl;
		mkfile << "SYSLIBS += " << userAdd[5] << endl;
		mkfile << endl;
		mkfile << "include $(cwd)/BuildSystem/global" << endl;
		mkfile << "include $(cwd)/BuildSystem/obj" << endl;
		mkfile << "include $(cwd)/BuildSystem/bin" << endl;
		mkfile << "include $(cwd)/BuildSystem/phony" << endl;
		mkfile.close();

		//obj
		map<string, string> obj_dep;  //one map is for unique
		string obj_line;
		bool flag=true;

		if(access(build_system_obj_path.c_str(), F_OK) == 0)
		{
			ifstream obj_file(build_system_obj_path.c_str());
			string temp;
			string key;
			string dep_context;
			string::iterator it;
			while(getline(obj_file, temp))
			{
				it = temp.begin();
				if(*it == '$' && !flag) { flag = !flag; }
				if(*it == '$' && flag){
					while( *it != '/' ) ++it;
					++it;
					while( *it != '.' ) { key.push_back(*it); ++it; }
					while( *it != ':' ) ++it;
					++it;
					while( it != temp.end()){ dep_context.push_back(*it); ++it; }
					obj_dep[key] = dep_context;
					key.clear();
					dep_context.clear();
					flag = !flag;
				}
			}
			obj_file.close();
		}

		ofstream objfile;
		objfile.open(build_system_obj_path.c_str());
		objfile <<  makefile_comment() << endl << endl;
		objfile << dep_command(objects_buffer) << endl << endl;

		for(vector<string>::iterator it= objects_buffer.begin(); it != objects_buffer.end(); ++it)
		{
			obj_command_template(objfile,*it, obj_dep);
		}
		objfile.close();
	}

	return 0;
}

